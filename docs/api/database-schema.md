# TAPPR Database Schema

This document describes the database schema used by the TAPPR API. The API uses Supabase as its database backend, which is built on PostgreSQL.

## Tables

### brews

The `brews` table stores information about brews (beers) in the system.

| Column Name | Data Type | Description | Constraints |
|-------------|-----------|-------------|-------------|
| id | integer | Unique identifier for the brew | Primary Key, Auto-increment |
| name | text | Name of the brew | Not Null |
| style | text | Style of the brew (e.g., IPA, Stout) | Not Null |
| abv | real | Alcohol by volume percentage | Not Null |
| ibu | double precision | International Bitterness Units (can have decimal values) | Nullable |
| description | text | Description of the brew | Nullable |
| brew_date | text | Date the brew was brewed (ISO format: YYYY-MM-DD) | Not Null |
| keg_level | integer | Current keg level percentage (0-100) | Not Null, Default: 100 |
| api_brew_uuid | text | UUID generated by the API (unique immutable key) | Not Null, Unique |
| brew_uuid | text | UUID provided by the companion app | Not Null |
| recipe_id | text | Reference to the recipe | Nullable, Foreign Key to recipes.recipe_id |
| created_at | timestamp with time zone | Timestamp when the record was created | Not Null, Default: current_timestamp |
| updated_at | timestamp with time zone | Timestamp when the record was last updated | Not Null, Default: current_timestamp |

### recipes

The `recipes` table stores information about beer recipes in the system.

| Column Name | Data Type | Description | Constraints |
|-------------|-----------|-------------|-------------|
| id | integer | Unique identifier for the recipe | Primary Key, Auto-increment |
| recipe_id | text | Deterministic UUID generated from platform, author, and name | Not Null, Unique |
| name | text | Original recipe name | Not Null |
| normalized_name | text | Normalized name for matching (lowercase, no special chars) | Not Null |
| author | text | Recipe author | Not Null |
| normalized_author | text | Normalized author name for matching | Not Null |
| platform | text | Source platform (e.g., "grainfather") | Not Null |
| description | text | Description of the recipe | Nullable |
| style | text | Beer style | Nullable |
| created_at | timestamp with time zone | Timestamp when the record was created | Not Null, Default: current_timestamp |
| updated_at | timestamp with time zone | Timestamp when the record was last updated | Not Null, Default: current_timestamp |

### reviews

The `reviews` table stores reviews for brews (beers) in the system.

| Column Name | Data Type | Description | Constraints |
|-------------|-----------|-------------|-------------|
| id | integer | Unique identifier for the review | Primary Key, Auto-increment |
| review_id | text | UUID for the review | Not Null, Unique |
| api_brew_uuid | text | UUID of the brew being reviewed (API-generated) | Not Null, Foreign Key to brews.api_brew_uuid |
| brew_uuid | text | UUID of the brew in the companion app | Nullable |
| reviewer_id | text | ID of the reviewer (if authenticated) | Nullable |
| reviewer_name | text | Name of the reviewer | Nullable |
| is_anonymous | boolean | Whether the review is anonymous | Not Null, Default: false |
| review_date | text | Date of the review (ISO format) | Not Null |
| review_type | text | Type of review: "quick", "standard", or "expert" | Not Null |
| quick_review | jsonb | Quick review data (stored as JSON) | Not Null |
| standard_review | jsonb | Standard review data (stored as JSON) | Nullable |
| expert_review | jsonb | Expert review data (stored as JSON) | Nullable |
| created_at | timestamp with time zone | Timestamp when the record was created | Not Null, Default: current_timestamp |
| updated_at | timestamp with time zone | Timestamp when the record was last updated | Not Null, Default: current_timestamp |

## Data Mapping

### API to Database Mapping

The API uses camelCase for property names, while the database uses snake_case for column names. Here's how they map:

#### Brew Model

| API Property | Database Column |
|--------------|-----------------|
| id | id |
| name | name |
| style | style |
| abv | abv |
| ibu | ibu |
| description | description |
| brewDate | brew_date |
| kegLevel | keg_level |
| apiBrewUuid | api_brew_uuid |
| brewUuid | brew_uuid |
| recipeId | recipe_id |
| createdAt | created_at |
| updatedAt | updated_at |

#### Recipe Model

| API Property | Database Column |
|--------------|------------------|
| id | id |
| recipeId | recipe_id |
| name | name |
| normalizedName | normalized_name |
| author | author |
| normalizedAuthor | normalized_author |
| platform | platform |
| description | description |
| style | style |
| createdAt | created_at |
| updatedAt | updated_at |

#### Review Model

| API Property | Database Column |
|--------------|-----------------|
| id | id |
| reviewId | review_id |
| apiBrewUuid | api_brew_uuid |
| brewUuid | brew_uuid |
| reviewerId | reviewer_id |
| reviewerName | reviewer_name |
| isAnonymous | is_anonymous |
| reviewDate | review_date |
| reviewType | review_type |
| quickReview | quick_review |
| standardReview | standard_review |
| expertReview | expert_review |
| createdAt | created_at |
| updatedAt | updated_at |

### JSON Data Structure

Some fields in the database are stored as JSON. Here's the structure of these fields:

#### quick_review

```json
{
  "overallRating": 4,
  "comments": "Great brew, would drink again!"
}
```

#### standard_review

```json
{
  "appearance": 4,
  "aroma": 5,
  "taste": 4,
  "mouthfeel": 3,
  "comments": "Nice golden color, strong hop aroma, good balance of flavors"
}
```

#### expert_review

```json
{
  "appearance": {
    "clarity": 4,
    "color": 5,
    "head": 4,
    "notes": "Golden amber with excellent head retention"
  },
  "aroma": {
    "intensity": 4,
    "maltiness": 3,
    "hoppiness": 5,
    "fruitiness": 4,
    "otherAromatics": 3,
    "notes": "Strong citrus and pine hop aroma with supporting malt backbone"
  },
  "taste": {
    "flavorIntensity": 4,
    "maltCharacter": 3,
    "hopCharacter": 5,
    "bitterness": 4,
    "sweetness": 2,
    "balance": 4,
    "notes": "Bold hop flavor with enough malt to support, clean bitterness"
  },
  "mouthfeel": {
    "body": 3,
    "carbonation": 4,
    "warmth": 2,
    "creaminess": 3,
    "notes": "Medium body with lively carbonation"
  },
  "aftertaste": {
    "duration": 4,
    "pleasantness": 4,
    "notes": "Pleasant lingering hop bitterness"
  },
  "styleAccuracy": 9
}
```

## Indexes

The following indexes are recommended for optimal performance:

### brews table

- Primary Key: `id`
- Unique Index: `api_brew_uuid`
- Index: `brew_uuid` (for lookups by companion app UUID)
- Index: `recipe_id` (for lookups by recipe)

### recipes table

- Primary Key: `id`
- Unique Index: `recipe_id`
- Index: `normalized_name` (for searching by name)
- Index: `normalized_author` (for searching by author)
- Index: `platform` (for filtering by platform)
- Index: `style` (for filtering by style)

### reviews table

- Primary Key: `id`
- Unique Index: `review_id`
- Index: `api_brew_uuid` (for faster lookups of reviews by brew)
- Index: `brew_uuid` (for lookups by companion app UUID)

## Notes

- The `ibu` column is stored as a `double precision` (float8) to allow for decimal values.
- Date fields are stored as text in ISO format (YYYY-MM-DD) for simplicity and compatibility.
- JSON fields are stored using PostgreSQL's `jsonb` type for efficient storage and querying.
- The API handles the conversion between camelCase (API) and snake_case (database) property names.
- The `api_brew_uuid` field is the primary reference for brews in the database and is used for relationships with other tables.
- The `brew_uuid` field is used as a reference for the companion app and is not used for database relationships.
- The `recipe_id` field in the `recipes` table is a deterministic UUID generated from the platform, author, and recipe name, ensuring that the same recipe always gets the same UUID.
- The `recipe_id` field in the `brews` table references the `recipe_id` field in the `recipes` table, establishing a relationship between brews and the recipes they are based on.
